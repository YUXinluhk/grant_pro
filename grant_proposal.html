<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基金申报书AI撰写助手 V4 (布局优化版)</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for rendering Markdown output -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .prose h1, .prose h2, .prose h3 { color: #1f2937; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.3em; }
        .prose p { line-height: 1.7; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        details > summary { cursor: pointer; }
        .control-panel button { transition: all 0.2s ease-in-out; }
        .control-panel button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .tab-btn { transition: all 0.2s ease; }
        .tab-btn.active { border-color: #3b82f6; color: #3b82f6; background-color: #eff6ff; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">基金申报书多智能体撰写系统 V4</h1>
            <p class="mt-3 text-lg text-gray-600">动态模型加载 · 迭代式工作流 · 专业布局</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            <!-- Left Column: Inputs and Controls -->
            <div class="lg:col-span-2 bg-white p-6 rounded-2xl shadow-lg border border-gray-200 space-y-6 self-start">
                <div id="config-panel">
                    <h2 class="text-xl font-semibold border-b pb-3 mb-4">参数配置</h2>
                    <div class="space-y-4">
                        <div class="border-b border-gray-200 pb-4">
                            <h3 class="text-md font-semibold text-gray-800 mb-2">API 连接配置</h3>
                            <div>
                                <label for="apiProvider" class="block text-sm font-medium text-gray-700 mb-1">选择模型提供商:</label>
                                <select id="apiProvider" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="gemini_native">Google Gemini (原生)</option>
                                    <option value="openrouter">OpenRouter</option>
                                    <option value="openai_compatible">OpenAI 兼容 API (如本地模型, 其他代理)</option>
                                    <option value="custom">自定义 (需要API Base URL)</option>
                                </select>
                            </div>
                            <div class="mt-3">
                                <label for="apiKey" id="apiKeyLabel" class="block text-sm font-medium text-gray-700 mb-1">API Key:</label>
                                <input type="password" id="apiKey" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="输入您的API密钥">
                            </div>
                            <div id="apiBaseUrlContainer" class="mt-3">
                                <label for="apiBaseUrl" id="apiBaseUrlLabel" class="block text-sm font-medium text-gray-700 mb-1">API Base URL:</label>
                                <input type="text" id="apiBaseUrl" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="例如: https://api.openai.com/v1">
                            </div>
                            <button id="fetchModelsButton" class="mt-4 w-full bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                                连接并获取模型
                            </button>
                            <div id="connectivityStatus" class="text-sm mt-2 min-h-[1.25em]"></div>
                        </div>
                        <div>
                            <label for="initialPrompt" class="block text-sm font-medium text-gray-700 mb-1 pt-2">初步研究构想</label>
                            <textarea id="initialPrompt" rows="5" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="输入您的研究构想...">我想研究蛋白质X和疾病Y之间的关系，特别关注其在细胞信号通路中的作用机制。</textarea>
                        </div>
                        <div>
                            <h3 class="text-md font-medium text-gray-700 mb-2">模型选择</h3>
                            <div class="space-y-3">
                                <div>
                                    <label for="mainLlm" class="block text-sm text-gray-600">核心模型 (用于创作和分析)</label>
                                    <select id="mainLlm" class="w-full mt-1 px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
                                </div>
                                <div>
                                    <label for="knowledgeLlm" class="block text-sm text-gray-600">知识模型 (用于文献综述)</label>
                                    <select id="knowledgeLlm" class="w-full mt-1 px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
                                </div>
                            </div>
                        </div>
                        <div class="space-y-3">
                            <h3 class="text-md font-medium text-gray-700">知识库管理</h3>
                            <div>
                                <label for="fileUpload" class="block text-sm text-gray-600 mb-1">上传文件 (txt, md, pdf)</label>
                                <input type="file" id="fileUpload" multiple accept=".txt,.md,.text,.pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                            </div>
                            <div id="knowledgeBaseStatus" class="text-xs text-gray-500 p-2 bg-gray-100 rounded-md">知识库为空。</div>
                            <button id="clearKnowledgeBase" class="w-full text-sm bg-red-500 text-white font-semibold py-2 px-4 rounded-lg shadow-sm hover:bg-red-600">清除知识库</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Outputs -->
            <div class="lg:col-span-3 bg-white p-6 rounded-2xl shadow-lg border border-gray-200">
                <!-- MOVED: Workflow Control Panel -->
                <div id="control-panel" class="control-panel space-y-3 pb-6 mb-6 border-b-2 border-dashed">
                     <h2 class="text-xl font-semibold">工作流程控制</h2>
                     <button id="workflowButton" class="w-full bg-blue-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-blue-700 flex items-center justify-center">
                        <span id="buttonText">开始流程</span>
                        <div id="loader" class="loader hidden ml-3"></div>
                    </button>
                    <div id="revision-controls" class="hidden space-y-3">
                        <h3 class="text-md font-semibold text-center text-orange-600">进入修订模式</h3>
                        <p class="text-sm text-gray-600">您现在可以直接在下方报告区修改草稿。完成后，可多次点击“优化”进行迭代，或在满意后点击“完成”继续下一步。</p>
                        <button id="reviseButton" class="w-full bg-orange-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-orange-600">迭代优化当前草稿</button>
                        <button id="finishRevisionButton" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-green-700">完成修订，继续生成终稿</button>
                    </div>
                </div>

                <!-- Tab Navigation -->
                <div class="border-b border-gray-200">
                    <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                        <button class="tab-btn active whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm" data-tab="report">报告/编辑区</button>
                        <button class="tab-btn whitespace-nowrap py-3 px-1 border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 font-medium text-sm" data-tab="prompts">Prompts</button>
                        <button class="tab-btn whitespace-nowrap py-3 px-1 border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 font-medium text-sm" data-tab="logs">执行日志</button>
                        <button class="tab-btn whitespace-nowrap py-3 px-1 border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 font-medium text-sm" data-tab="roadmap">技术路线图</button>
                    </nav>
                </div>

                <!-- Tab Content -->
                <div class="mt-6">
                    <div class="tab-content" id="tab-report">
                        <div id="reportOutput" class="prose max-w-none h-[65vh] overflow-y-auto bg-gray-50 p-4 rounded-lg border border-gray-200">报告内容将在此处显示。</div>
                    </div>
                    <div class="tab-content hidden" id="tab-prompts">
                        <div id="promptsContainer" class="space-y-4 h-[65vh] overflow-y-auto"></div>
                    </div>
                    <div class="tab-content hidden" id="tab-logs">
                        <div id="logOutput" class="h-[65vh] bg-gray-900 text-white font-mono text-sm p-4 rounded-lg overflow-y-auto border border-gray-700">请先配置参数并点击“开始流程”...</div>
                    </div>
                    <div class="tab-content hidden" id="tab-roadmap">
                        <div id="roadmapOutput" class="w-full h-[65vh] overflow-auto bg-gray-50 p-4 rounded-lg border border-gray-200 flex justify-center items-center"></div>
                    </div>
                </div>
            </div>
        </div>
        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>由多模型AI驱动的前端应用</p>
        </footer>
    </div>

    <script type="module">
        import * as pdfjsLib from "https://mozilla.github.io/pdf.js/build/pdf.mjs";
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://mozilla.github.io/pdf.js/build/pdf.worker.mjs`;

        const PROMPTS = {
            clarify_objectives: `##Role:\nI am a professor in the field of [FIELD], with many years of deep cultivation in this field, and I have a wealth of academic knowledge and research experience. I am proficient in Chinese writing, grammar rules and format specifications, and I am good at writing grant proposals for research funds.\n\n##Goals:\nAccording to the user's topic selection, help them write the "research content, research objectives, and key scientific issues to be solved" part of the fund application, and fully reflect the innovation and feasibility of the project, so as to get the approval of review experts.`,
            literature_review: `##Role:\nI am a professor in the field of [FIELD].\n\n##Goals:\nAccording to the user's topic selection AND the provided knowledge base, help them write the "Basis for Project Establishment" part. Fully reflect the scientificity, innovation and necessity of the project.`,
            research_plan: `##Role:\nI am a professor in the field of [FIELD].\n\n##Goals:\nAccording to the user's topic selection, help them write the "Proposed Research Plan and Feasibility Analysis" part.`,
            innovation: `##Role:\nI am a professor in the field of [FIELD].\n\n##Goals:\nHelp them write the "Features and Innovations of this Project" part.`,
            reviser: `##Role:\nI am an expert editor. My goal is to revise the provided drafts based on the user's direct edits and the AI reviewer's feedback. I will integrate the suggestions to produce a more polished and coherent version. I will output the complete, revised text for all sections that were modified.\n\n## AI Reviewer Feedback:\n[REVIEW_FEEDBACK]\n\n## User's Revised Drafts:\n[USER_DRAFTS]`,
            reviewer: `##Role:\nI am a professor in the field of [FIELD] and an experienced fund review expert.\n\n##Goals:\nFor the user's Chinese grant proposal draft, as a fund review expert, I will help with the pre-review, point out the problems and improvement suggestions of each part of the application.`,
            title_abstract: `##Role:\nI am a professor in the field of [FIELD].\n\n##Goals:\nFormulate the "title" and "abstract" of the fund application. Your output MUST be a JSON object with two keys: "title" and "abstract".`,
            technical_roadmap: `##Role:\nI am a professor in the field of [FIELD], specializing in creating clear, professional technical roadmaps for grant proposals.\n\n##Goals:\nBased on the provided final research content, generate a technical roadmap. The roadmap should be structured logically, highlighting key stages, methods, and expected outcomes to demonstrate the project's feasibility and innovation.\n\n##Requirements:\n- The output must be a single, complete SVG code block. Do not wrap it in HTML or markdown.\n- The SVG should be visually clean, using simple shapes (rectangles, arrows) and a clear hierarchy.\n- Use a professional, low-saturation color scheme.\n- Ensure text is legible and fits within the shapes.\n- The overall structure should logically flow from the research objectives to the final outcome.\n\n##Final Research Content:\n[RESEARCH_CONTENT]`
        };

        let graphState = {};
        let currentStep = 0;
        let researchField = '通用领域';

        const elements = {
            // Existing elements
            apiKey: document.getElementById('apiKey'),
            apiBaseUrl: document.getElementById('apiBaseUrl'),
            initialPrompt: document.getElementById('initialPrompt'),
            // New elements for provider selection
            apiProvider: document.getElementById('apiProvider'),
            apiKeyLabel: document.getElementById('apiKeyLabel'),
            apiBaseUrlContainer: document.getElementById('apiBaseUrlContainer'),
            apiBaseUrlLabel: document.getElementById('apiBaseUrlLabel'),
            fetchModelsButton: document.getElementById('fetchModelsButton'),
            connectivityStatus: document.getElementById('connectivityStatus'),
            // Continuing existing elements
            mainLlm: document.getElementById('mainLlm'),
            knowledgeLlm: document.getElementById('knowledgeLlm'),
            workflowButton: document.getElementById('workflowButton'),
            logOutput: document.getElementById('logOutput'),
            reportOutput: document.getElementById('reportOutput'),
            loader: document.getElementById('loader'),
            buttonText: document.getElementById('buttonText'),
            fileUpload: document.getElementById('fileUpload'),
            knowledgeBaseStatus: document.getElementById('knowledgeBaseStatus'),
            clearKnowledgeBase: document.getElementById('clearKnowledgeBase'),
            promptsContainer: document.getElementById('promptsContainer'),
            revisionControls: document.getElementById('revision-controls'),
            reviseButton: document.getElementById('reviseButton'),
            finishRevisionButton: document.getElementById('finishRevisionButton'),
            // roadmapContainer was unused and the ID did not exist in HTML.
            roadmapOutput: document.getElementById('roadmapOutput'),
            tabButtons: document.querySelectorAll('.tab-btn'),
            tabContents: document.querySelectorAll('.tab-content'),
        };

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            elements.logOutput.innerHTML += `<div><span class="text-gray-500">${timestamp}</span>: <span class="text-green-400">${message}</span></div>`;
            elements.logOutput.scrollTop = elements.logOutput.scrollHeight;
        }
        function logError(message) {
            const timestamp = new Date().toLocaleTimeString();
            elements.logOutput.innerHTML += `<div><span class="text-gray-500">${timestamp}</span>: <span class="text-red-400">${message}</span></div>`;
            elements.logOutput.scrollTop = elements.logOutput.scrollHeight;
        }
        function toggleLoading(isLoading, text = '开始流程') {
            elements.workflowButton.disabled = isLoading;
            elements.buttonText.textContent = isLoading ? 'AI正在工作中...' : text;
            elements.loader.classList.toggle('hidden', !isLoading);
        }

        async function callLlm(prompt, modelName, apiKey, apiBaseUrl) {
            let endpoint = '';
            let headers = { 'Content-Type': 'application/json' };
            let body = {};

            if (modelName.startsWith('gemini-') && !apiBaseUrl) {
                endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
                body = { contents: [{ parts: [{ text: prompt }] }] };
            } else {
                // This path is taken if modelName is not 'gemini-' OR if apiBaseUrl is provided.
                // If apiBaseUrl is NOT provided here, it means a non-Gemini model was chosen without a required Base URL.
                if (!apiBaseUrl) throw new Error("此模型配置需要 API Base URL，但未提供。");
                endpoint = `${apiBaseUrl.replace(/\/$/, '')}/chat/completions`;
                headers['Authorization'] = `Bearer ${apiKey}`;
                body = { model: modelName, messages: [{ role: 'user', content: prompt }] };
            }

            try {
                const response = await fetch(endpoint, { method: 'POST', headers, body: JSON.stringify(body) });
                if (!response.ok) {
                    let errorDataMessage = `HTTP status ${response.status}`;
                    try {
                        const errorData = await response.json();
                        // Attempt to extract a meaningful message from various possible error structures
                        errorDataMessage = errorData?.error?.message || // Standard OpenAI, Google, some OpenRouter
                                         errorData?.error?.type ||    // Some OpenRouter (e.g., Anthropic)
                                         errorData?.message ||        // Direct message property
                                         JSON.stringify(errorData);   // Fallback to stringifying the whole error object
                    } catch (e) {
                        // If response body isn't JSON or JSON parsing fails
                        try {
                            const errorText = await response.text();
                            errorDataMessage = `${response.statusText || 'Error'}: ${errorText || '(No further error details in response body)'}`;
                        } catch (textErr) {
                             // Fallback if reading response.text() also fails
                             errorDataMessage = `${response.statusText || 'Error'} (Could not parse error response body and failed to read as text)`;
                        }
                    }
                    throw new Error(`API Error (${modelName}): ${response.status} - ${errorDataMessage}`);
                }
                const data = await response.json(); // Assuming response.ok means data is valid JSON

                if (modelName.startsWith('gemini-') && !apiBaseUrl) { // Native Gemini call
                    const textContent = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (typeof textContent === 'undefined') {
                        logError(`Gemini API (${modelName}) returned a 200 OK but the expected content is missing. Full response: ${JSON.stringify(data)}`);
                        if (data.promptFeedback && data.promptFeedback.blockReason) {
                             throw new Error(`Gemini API request to ${modelName} was blocked due to: ${data.promptFeedback.blockReason}. Safety ratings: ${JSON.stringify(data.promptFeedback.safetyRatings)}`);
                        }
                        throw new Error(`Gemini API call to ${modelName} was successful (200 OK) but no valid content was found in the response.`);
                    }
                    return textContent;
                } else { // OpenAI-compatible or other proxied models
                    const messageContent = data.choices?.[0]?.message?.content;
                    if (typeof messageContent === 'undefined') {
                        logError(`Compatible API (${modelName}) returned a 200 OK but the expected content (choices[0].message.content) is missing. Full response: ${JSON.stringify(data)}`);
                        if (data.choices && data.choices.length > 0 && data.choices[0].finish_reason) {
                            throw new Error(`Compatible API call to ${modelName} (200 OK) finished with reason '${data.choices[0].finish_reason}' but no content was returned.`);
                        }
                        if (data.error) { // Some APIs might return 200 OK with an error object in the body
                             throw new Error(`Compatible API call to ${modelName} (200 OK) returned an error object in the response body: ${data.error.message || JSON.stringify(data.error)}`);
                        }
                        throw new Error(`Compatible API call to ${modelName} was successful (200 OK) but no valid content was found in the response.`);
                    }
                    return messageContent;
                }
            } catch (error) {
                // This catches:
                // 1. Network errors from fetch itself (e.g., DNS failure, server unreachable).
                // 2. Errors from response.json() if the response body isn't valid JSON (e.g. HTML error page).
                // 3. Errors explicitly thrown from the blocks above (e.g., !response.ok, missing content).
                const originalErrorMessage = error.message;
                // Add modelName to the error if not already present for easier debugging from logs.
                const finalErrorMessage = originalErrorMessage.includes(modelName) ? originalErrorMessage : `Model call failed for ${modelName}: ${originalErrorMessage}`;
                logError(finalErrorMessage); // Log the detailed error.
                throw new Error(finalErrorMessage); // Re-throw to be caught by runWorkflow.
            }
        }

        function getPromptWithState(promptText, state, knowledgeBaseContent) {
            let finalPrompt = promptText;
            if (knowledgeBaseContent) {
                finalPrompt = `Please refer to the following knowledge base content:\n\n<knowledge_base>\n${knowledgeBaseContent}\n</knowledge_base>\n\nAnd now, follow these instructions:\n${finalPrompt}`;
            }
            return `${finalPrompt}\n\n## Current Project State:\n${JSON.stringify(state, null, 2)}`;
        }

        function updateReportOutput(content, isEditable = false) {
            if (isEditable) {
                elements.reportOutput.innerHTML = `<textarea id="editor" class="w-full h-full bg-yellow-50 border-2 border-yellow-400 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-yellow-500">${content}</textarea>`;
            } else {
                elements.reportOutput.innerHTML = marked.parse(content.replace(/\n/g, '<br>'));
            }
        }

        function updateKnowledgeBaseStatus(content) {
            const sizeInKB = content ? (content.length / 1024).toFixed(2) : 0;
            elements.knowledgeBaseStatus.textContent = content ? `知识库已加载 (${sizeInKB} KB)。` : '知识库为空。';
            elements.knowledgeBaseStatus.classList.toggle('text-green-600', !!content);
            elements.knowledgeBaseStatus.classList.toggle('text-gray-500', !content);
        }

        elements.fileUpload.addEventListener('change', async (event) => {
            const files = event.target.files;
            if (!files.length) return;
            let combinedText = localStorage.getItem('knowledgeBase') || '';
            log(`正在加载 ${files.length} 个文件...`);
            for (const file of Array.from(files)) {
                try {
                    const text = file.type === 'application/pdf' ? await parsePdf(file) : await file.text();
                    combinedText += text + '\n\n---\n\n';
                    log(`✅ 文件 ${file.name} 加载成功。`);
                } catch (e) {
                    logError(`处理文件 ${file.name} 失败: ${e.message}`);
                }
            }
            try {
                localStorage.setItem('knowledgeBase', combinedText);
                updateKnowledgeBaseStatus(combinedText);
            } catch (e) {
                logError(`存储知识库失败 (Failed to save knowledge base): ${e.message}. 可能已超出浏览器存储限制。`);
                // Optionally, revert to previous state or clear if appropriate
                // For now, just log the error. The UI might be out of sync if this fails.
            }
        });

        async function parsePdf(file) {
            const loadingTask = pdfjsLib.getDocument(URL.createObjectURL(file));
            const pdf = await loadingTask.promise;
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                fullText += textContent.items.map(s => s.str).join(' ') + '\n';
            }
            return fullText;
        }

        elements.clearKnowledgeBase.addEventListener('click', () => {
            localStorage.removeItem('knowledgeBase');
            updateKnowledgeBaseStatus(null);
            log('知识库已清除。');
        });

        function populatePrompts() {
            elements.promptsContainer.innerHTML = '';
            for (const key in PROMPTS) {
                const promptDiv = document.createElement('div');
                promptDiv.innerHTML = `
                    <label for="prompt-${key}" class="block text-sm font-medium text-gray-700 mb-1">${key}</label>
                    <textarea id="prompt-${key}" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" rows="8">${PROMPTS[key]}</textarea>
                `;
                elements.promptsContainer.appendChild(promptDiv);
            }
        }

        function getCurrentPrompts() {
            const currentPrompts = {};
            for (const key in PROMPTS) {
                currentPrompts[key] = document.getElementById(`prompt-${key}`).value.replace(/\[FIELD\]/g, researchField.trim());
            }
            return currentPrompts;
        }

        const defaultModels = {
            main: [
                { group: "Google Gemini (原生)", models: ["gemini-1.5-pro-latest", "gemini-1.5-flash-latest"] },
                { group: "OpenAI (通过 OpenRouter)", models: ["openai/gpt-4o"] },
                { group: "Anthropic (通过 OpenRouter)", models: ["anthropic/claude-3.5-sonnet", "anthropic/claude-3-opus"] },
                { group: "Meta (通过 OpenRouter)", models: ["meta-llama/llama-3.1-405b-instruct"] },
                { group: "硅基流动 (Moonshot AI)", models: ["moonshot-v1-8k", "moonshot-v1-32k", "moonshot-v1-128k"] }
            ],
            knowledge: [
                { group: "Google Gemini (原生)", models: ["gemini-1.5-flash-latest"] },
                { group: "OpenRouter (经济型)", models: ["anthropic/claude-3-haiku", "mistralai/mistral-7b-instruct"] },
                { group: "硅基流动 (Moonshot AI)", models: ["moonshot-v1-8k"] }
            ]
        };

        function populateModelSelect(selectElement, modelGroups) {
            selectElement.innerHTML = ''; // Clear existing options first
            if (!modelGroups || modelGroups.length === 0) {
                selectElement.innerHTML = '<option value="">无可用模型</option>';
                return;
            }
            modelGroups.forEach(group => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = group.group;
                group.models.forEach(modelId => {
                    const option = document.createElement('option');
                    option.value = modelId;
                    option.textContent = modelId.split('/').pop(); // Display cleaner name
                    optgroup.appendChild(option);
                });
                selectElement.appendChild(optgroup);
            });
             if (selectElement.options.length === 0) { // Should not happen if modelGroups is not empty, but as a safeguard
                selectElement.innerHTML = '<option value="">无可用模型</option>';
            }
        }

        // fetchAndUpdateModels function is now removed as its functionality is superseded by handleFetchModels.

        // elements.apiBaseUrl.addEventListener('blur', fetchAndUpdateModels); // This event listener is removed.

        function updateProviderUI() {
            const selectedProvider = elements.apiProvider.value;

            // Clear model lists and status
            const placeholderOption = '<option value="">请先连接并获取模型</option>';
            elements.mainLlm.innerHTML = placeholderOption;
            elements.knowledgeLlm.innerHTML = placeholderOption;
            elements.connectivityStatus.textContent = '';

            switch (selectedProvider) {
                case 'gemini_native':
                    elements.apiKeyLabel.textContent = 'Google API Key:';
                    elements.apiKey.placeholder = '输入您的 Google API 密钥';
                    elements.apiBaseUrlContainer.classList.add('hidden');
                    elements.apiBaseUrl.value = ''; // Clear any previous value
                    break;
                case 'openrouter':
                    elements.apiKeyLabel.textContent = 'OpenRouter API Key:';
                    elements.apiKey.placeholder = '输入您的 OpenRouter API 密钥 (sk-or-...)';
                    elements.apiBaseUrlContainer.classList.remove('hidden');
                    elements.apiBaseUrlLabel.textContent = 'OpenRouter API Base URL:';
                    elements.apiBaseUrl.value = 'https://openrouter.ai/api/v1';
                    elements.apiBaseUrl.placeholder = 'https://openrouter.ai/api/v1';
                    break;
                case 'openai_compatible':
                    elements.apiKeyLabel.textContent = 'API Key (可选):';
                    elements.apiKey.placeholder = '如果需要，请输入API Key';
                    elements.apiBaseUrlContainer.classList.remove('hidden');
                    elements.apiBaseUrlLabel.textContent = '兼容 API Base URL:';
                    elements.apiBaseUrl.value = '';
                    elements.apiBaseUrl.placeholder = '例如: http://localhost:1234/v1';
                    break;
                case 'custom':
                    elements.apiKeyLabel.textContent = 'API Key:';
                    elements.apiKey.placeholder = '输入您的 API Key';
                    elements.apiBaseUrlContainer.classList.remove('hidden');
                    elements.apiBaseUrlLabel.textContent = '自定义 API Base URL:';
                    elements.apiBaseUrl.value = '';
                    elements.apiBaseUrl.placeholder = '输入完整的 API Base URL';
                    break;
                default:
                    elements.apiKeyLabel.textContent = 'API Key:';
                    elements.apiBaseUrlContainer.classList.add('hidden');
            }
        }

        elements.apiProvider.addEventListener('change', updateProviderUI);

        async function handleFetchModels() {
            const provider = elements.apiProvider.value;
            const apiKey = elements.apiKey.value.trim();
            const apiBaseUrl = elements.apiBaseUrl.value.trim();

            elements.connectivityStatus.textContent = '正在检查连接并获取模型...';
            elements.connectivityStatus.classList.remove('text-red-500', 'text-green-500');
            elements.connectivityStatus.classList.add('text-blue-500');

            // Clear previous models
            elements.mainLlm.innerHTML = '<option value="">获取中...</option>';
            elements.knowledgeLlm.innerHTML = '<option value="">获取中...</option>';

            try {
                let fetchedModels = [];
                let modelGroups = [];

                switch (provider) {
                    case 'gemini_native':
                        if (!apiKey) {
                            throw new Error("Google API Key 未提供。");
                        }
                        // For native Gemini, we don't fetch from an endpoint, we use predefined defaults.
                        // Filter defaultModels for Gemini entries.
                        const geminiMainModels = defaultModels.main.find(group => group.group.toLowerCase().includes("gemini"));
                        const geminiKnowledgeModels = defaultModels.knowledge.find(group => group.group.toLowerCase().includes("gemini"));

                        if (geminiMainModels) modelGroups.push(geminiMainModels);
                        // Add other default groups too, or just Gemini? For now, let's assume only Gemini for this provider.
                        populateModelSelect(elements.mainLlm, geminiMainModels ? [geminiMainModels] : []);
                        populateModelSelect(elements.knowledgeLlm, geminiKnowledgeModels ? [geminiKnowledgeModels] : []);

                        elements.connectivityStatus.textContent = '已选择 Gemini (原生)。默认模型已加载。';
                        elements.connectivityStatus.classList.add('text-green-500');
                        return; // Exit early

                    case 'openrouter':
                    case 'openai_compatible':
                    case 'custom':
                        if (!apiBaseUrl) {
                            throw new Error("API Base URL 未提供。");
                        }
                        // For OpenRouter and OpenAI compatible, API key might be optional for some local LLMs
                        if ((provider === 'openrouter' || provider === 'custom') && !apiKey) {
                             // OpenRouter and typically custom setups would require an API key.
                            throw new Error("API Key 未提供。");
                        }

                        const modelsUrl = `${apiBaseUrl.replace(/\/$/, '')}/models`;
                        const headers = { 'Authorization': `Bearer ${apiKey}` };

                        const response = await fetch(modelsUrl, apiKey ? { headers } : {}); // Don't send auth header if no API key (for truly open local LLMs)

                        if (!response.ok) {
                            const errorData = await response.text();
                            throw new Error(`获取模型列表失败: ${response.status} - ${errorData}`);
                        }
                        const data = await response.json();
                        // Standard OpenAI format is data.data, OpenRouter also uses data.data
                        if (data && data.data && Array.isArray(data.data)) {
                            fetchedModels = data.data.map(m => m.id).sort();
                        } else {
                            // Fallback for non-standard list, e.g. some local LLMs might return a flat list or { "models": [] }
                            // This part might need adjustment based on actual non-standard API responses.
                            // For now, we'll assume it's an array of strings if not data.data
                            if (Array.isArray(data)) { // Simple list of strings
                                fetchedModels = data.map(m => typeof m === 'string' ? m : m.id).sort();
                            } else if (data.models && Array.isArray(data.models)){ // like { models: ["id1", "id2"]}
                                fetchedModels = data.models.map(m => typeof m === 'string' ? m : m.id).sort();
                            } else {
                                console.warn("Model list response format not standard OpenAI. Full response:", data);
                                throw new Error("获取到的模型列表格式不识别。请检查API响应。");
                            }
                        }

                        if (fetchedModels.length === 0) {
                           throw new Error("API返回了空模型列表。");
                        }

                        modelGroups = [{ group: `来自 ${provider} 的模型`, models: fetchedModels }];
                        populateModelSelect(elements.mainLlm, modelGroups);
                        populateModelSelect(elements.knowledgeLlm, modelGroups);
                        elements.connectivityStatus.textContent = `连接成功！获取了 ${fetchedModels.length} 个模型。`;
                        elements.connectivityStatus.classList.add('text-green-500');
                        break;
                    default:
                        throw new Error("未知的API提供商。");
                }
            } catch (error) {
                logError(error.message);
                elements.connectivityStatus.textContent = `错误: ${error.message}`;
                elements.connectivityStatus.classList.add('text-red-500');
                // Fallback to default models on error
                populateModelSelect(elements.mainLlm, defaultModels.main);
                populateModelSelect(elements.knowledgeLlm, defaultModels.knowledge);
            } finally {
                 elements.connectivityStatus.classList.remove('text-blue-500');
            }
        }

        elements.fetchModelsButton.addEventListener('click', handleFetchModels);

        elements.tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                elements.tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                elements.tabContents.forEach(content => content.classList.add('hidden'));
                document.getElementById(`tab-${button.dataset.tab}`).classList.remove('hidden');
            });
        });

        const workflowSteps = [
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("步骤 0: 识别研究领域...");
                const fieldPrompt = `From the following research idea, extract the primary academic field in 1-3 words. For example, for "我想研究蛋白质X和疾病Y之间的关系...", the field is "分子生物学". Research Idea: "${elements.initialPrompt.value}". Field:`;
                researchField = await callLlm(fieldPrompt, mainLlm, apiKey, apiBaseUrl);
                log(`✅ 识别领域为: ${researchField.trim()}`);
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("步骤 1: 执行 '目标澄清'...");
                const prompt = getPromptWithState(getCurrentPrompts().clarify_objectives, { initial_prompt: graphState.initial_prompt });
                graphState.clarified_objectives = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                updateReportOutput(`### 目标、内容与关键科学问题\n\n${graphState.clarified_objectives}`);
                log("✅ '目标澄清' 完成。请确认后继续。");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("步骤 2: 执行 '文献综述'...");
                const prompt = getPromptWithState(getCurrentPrompts().literature_review, graphState, localStorage.getItem('knowledgeBase'));
                graphState.literature_review_draft = await callLlm(prompt, knowledgeLlm, apiKey, apiBaseUrl);
                updateReportOutput(`### 立论依据 (文献综述)\n\n${graphState.literature_review_draft}`);
                log("✅ '文献综述' 完成。请确认后继续。");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("步骤 3: 执行 '研究计划'...");
                const prompt = getPromptWithState(getCurrentPrompts().research_plan, graphState);
                graphState.research_plan_draft = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                updateReportOutput(`### 研究方案\n\n${graphState.research_plan_draft}`);
                log("✅ '研究计划' 完成。请确认后继续。");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("步骤 4: 执行 '创新点'...");
                const prompt = getPromptWithState(getCurrentPrompts().innovation, graphState);
                graphState.innovation_draft = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                updateReportOutput(`### 本项目的特色与创新之处\n\n${graphState.innovation_draft}`);
                log("✅ '创新点' 完成。请确认后继续。");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("步骤 5: 执行 'AI评审'...");
                const fullDraft = `立论依据:\n${graphState.literature_review_draft}\n\n研究方案:\n${graphState.research_plan_draft}\n\n创新之处:\n${graphState.innovation_draft}`;
                const prompt = getPromptWithState(getCurrentPrompts().reviewer, { full_draft: fullDraft });
                graphState.review_feedback = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                const combinedReport = `${fullDraft}\n\n---\n\n### AI 评审员意见\n\n${graphState.review_feedback}`;
                updateReportOutput(combinedReport, true);
                log("✅ 'AI评审' 完成。请直接修改上方草稿，然后点击“提交修改并启动优化”。");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("步骤 6: 执行 '修订优化'...");
                const userDrafts = document.getElementById('editor').value;
                let prompt = getCurrentPrompts().reviser.replace('[REVIEW_FEEDBACK]', graphState.review_feedback).replace('[USER_DRAFTS]', userDrafts);
                const revisedText = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                graphState.literature_review_draft = revisedText;
                graphState.research_plan_draft = '';
                graphState.innovation_draft = '';
                updateReportOutput(`### 修订后版本\n\n${revisedText}`, true); // Keep it editable
                log("✅ '修订优化' 完成。您可以继续修改并优化，或点击“完成修订”。");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("步骤 7: 执行 '标题和摘要'...");
                const prompt = getPromptWithState(getCurrentPrompts().title_abstract, graphState);
                const jsonStr = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                try {
                    let contentToParse = jsonStr.trim();
                    const jsonMatch = contentToParse.match(/```json\n([\s\S]*?)\n```/);

                    if (jsonMatch && jsonMatch[1]) {
                        contentToParse = jsonMatch[1].trim();
                    } else if (contentToParse.startsWith('{') && contentToParse.endsWith('}')) {
                        // Content already looks like a raw JSON object, use as is.
                    } else {
                        // Output is neither a recognized JSON markdown block nor a string that looks like a JSON object.
                        throw new Error("LLM output for title/abstract was not in the expected JSON format or a JSON markdown block.");
                    }

                    const parsed = JSON.parse(contentToParse);

                    if (parsed && typeof parsed.title === 'string' && typeof parsed.abstract === 'string') {
                        graphState.final_title = parsed.title;
                        graphState.final_abstract = parsed.abstract;
                    } else {
                        throw new Error("Parsed JSON for title/abstract does not contain valid 'title' (string) and 'abstract' (string) properties.");
                    }
                } catch(e) {
                    logError(`标题/摘要JSON解析失败 (Title/Abstract JSON parsing failed): ${e.message}. Raw LLM output was: "${jsonStr}"`);
                    graphState.final_title = "标题生成失败";
                    graphState.final_abstract = "摘要生成失败，请检查执行日志中的原始输出。";
                }
                updateReportOutput(`<h2>${graphState.final_title}</h2>\n\n<h3>摘要</h3>\n\n<p>${graphState.final_abstract}</p>`);
                log("✅ '标题和摘要' 完成。请确认后继续。");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("步骤 8: 执行 '技术路线图'...");
                document.querySelector('[data-tab="roadmap"]').click();
                // After revision steps (6 and user finalization), graphState.literature_review_draft
                // is expected to hold the complete revised body of the proposal.
                // graphState.research_plan_draft and graphState.innovation_draft are cleared at that stage.
                // So, the technical roadmap should be based on the consolidated content in graphState.literature_review_draft.
                const researchContent = graphState.literature_review_draft;
                let prompt = getCurrentPrompts().technical_roadmap.replace('[RESEARCH_CONTENT]', researchContent);
                const svgCode = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                elements.roadmapOutput.innerHTML = svgCode;
                log("✅ '技术路线图' 完成。");
            }
        ];

        async function runWorkflow() {
            const { apiKey, mainLlm, knowledgeLlm, apiBaseUrl } = {
                apiKey: elements.apiKey.value.trim(),
                mainLlm: elements.mainLlm.value,
                knowledgeLlm: elements.knowledgeLlm.value,
                apiBaseUrl: elements.apiBaseUrl.value.trim()
            };

            if (!apiKey || (!elements.initialPrompt.value.trim() && currentStep === 0)) {
                logError("错误：API密钥和研究构想不能为空。");
                return;
            }

            toggleLoading(true, '确认并继续');

            try {
                await workflowSteps[currentStep](apiKey, mainLlm, knowledgeLlm, apiBaseUrl);

                if (currentStep === 5) { // Just finished AI Review
                    currentStep = 6; // Set state to be ready for revision
                    toggleLoading(false);
                    elements.workflowButton.classList.add('hidden');
                    elements.revisionControls.classList.remove('hidden');
                } else {
                    currentStep++;
                    if (currentStep < workflowSteps.length) {
                        toggleLoading(false, '确认并继续');
                    } else {
                        log("🎉 全部流程已完成！");
                        toggleLoading(false, '流程结束');
                        elements.workflowButton.disabled = true;
                    }
                }
            } catch (error) {
                logError(`工作流程在步骤 ${currentStep} 中断: ${error.message}`);
                toggleLoading(false, '流程失败，请重试');
            }
        }

        elements.workflowButton.addEventListener('click', () => {
             if (currentStep === 0) {
                graphState = { initial_prompt: elements.initialPrompt.value.trim() };
             }
             runWorkflow();
        });

        elements.reviseButton.addEventListener('click', async () => {
            const { apiKey, mainLlm, apiBaseUrl } = {
                apiKey: elements.apiKey.value.trim(),
                mainLlm: elements.mainLlm.value,
                apiBaseUrl: elements.apiBaseUrl.value.trim()
            };
            elements.reviseButton.disabled = true;
            elements.finishRevisionButton.disabled = true;
            log("⚙️ 正在根据您的修改进行新一轮优化...");

            try {
                await workflowSteps[6](apiKey, mainLlm, null, apiBaseUrl);
            } catch (error) {
                logError(`修订优化失败: ${error.message}`);
            } finally {
                elements.reviseButton.disabled = false;
                elements.finishRevisionButton.disabled = false;
            }
        });

        elements.finishRevisionButton.addEventListener('click', () => {
            elements.revisionControls.classList.add('hidden');
            elements.workflowButton.classList.remove('hidden');
            currentStep = 7;
            // Before moving on, save the final edited text to graphState
            const finalEditorContent = document.getElementById('editor')?.value;
            if (finalEditorContent) {
                 // Save the final editor content, which is the consolidated proposal body,
                 // into graphState.literature_review_draft.
                 graphState.literature_review_draft = finalEditorContent;
            }
            runWorkflow();
        });

        window.onload = () => {
            populatePrompts();
            updateKnowledgeBaseStatus(localStorage.getItem('knowledgeBase'));
            updateProviderUI(); // Set initial UI state for the default provider
            // fetchAndUpdateModels() is removed. Model fetching is now user-triggered.
        };

    </script>
</body>
</html>
