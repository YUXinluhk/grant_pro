<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŸºé‡‘ç”³æŠ¥ä¹¦AIæ’°å†™åŠ©æ‰‹ V4 (å¸ƒå±€ä¼˜åŒ–ç‰ˆ)</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for rendering Markdown output -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .prose h1, .prose h2, .prose h3 { color: #1f2937; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.3em; }
        .prose p { line-height: 1.7; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        details > summary { cursor: pointer; }
        .control-panel button { transition: all 0.2s ease-in-out; }
        .control-panel button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .tab-btn { transition: all 0.2s ease; }
        .tab-btn.active { border-color: #3b82f6; color: #3b82f6; background-color: #eff6ff; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-10">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">åŸºé‡‘ç”³æŠ¥ä¹¦å¤šæ™ºèƒ½ä½“æ’°å†™ç³»ç»Ÿ V4</h1>
            <p class="mt-3 text-lg text-gray-600">åŠ¨æ€æ¨¡å‹åŠ è½½ Â· è¿­ä»£å¼å·¥ä½œæµ Â· ä¸“ä¸šå¸ƒå±€</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            <!-- Left Column: Inputs and Controls -->
            <div class="lg:col-span-2 bg-white p-6 rounded-2xl shadow-lg border border-gray-200 space-y-6 self-start">
                <div id="config-panel">
                    <h2 class="text-xl font-semibold border-b pb-3 mb-4">å‚æ•°é…ç½®</h2>
                    <div class="space-y-4">
                        <div class="border-b border-gray-200 pb-4">
                            <h3 class="text-md font-semibold text-gray-800 mb-2">API è¿æ¥é…ç½®</h3>
                            <div>
                                <label for="apiProvider" class="block text-sm font-medium text-gray-700 mb-1">é€‰æ‹©æ¨¡å‹æä¾›å•†:</label>
                                <select id="apiProvider" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="gemini_native">Google Gemini (åŸç”Ÿ)</option>
                                    <option value="openrouter">OpenRouter</option>
                                    <option value="openai_compatible">OpenAI å…¼å®¹ API (å¦‚æœ¬åœ°æ¨¡å‹, å…¶ä»–ä»£ç†)</option>
                                    <option value="custom">è‡ªå®šä¹‰ (éœ€è¦API Base URL)</option>
                                </select>
                            </div>
                            <div class="mt-3">
                                <label for="apiKey" id="apiKeyLabel" class="block text-sm font-medium text-gray-700 mb-1">API Key:</label>
                                <input type="password" id="apiKey" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="è¾“å…¥æ‚¨çš„APIå¯†é’¥">
                            </div>
                            <div id="apiBaseUrlContainer" class="mt-3">
                                <label for="apiBaseUrl" id="apiBaseUrlLabel" class="block text-sm font-medium text-gray-700 mb-1">API Base URL:</label>
                                <input type="text" id="apiBaseUrl" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="ä¾‹å¦‚: https://api.openai.com/v1">
                            </div>
                            <button id="fetchModelsButton" class="mt-4 w-full bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                                è¿æ¥å¹¶è·å–æ¨¡å‹
                            </button>
                            <div id="connectivityStatus" class="text-sm mt-2 min-h-[1.25em]"></div>
                        </div>
                        <div>
                            <label for="initialPrompt" class="block text-sm font-medium text-gray-700 mb-1 pt-2">åˆæ­¥ç ”ç©¶æ„æƒ³</label>
                            <textarea id="initialPrompt" rows="5" class="w-full px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="è¾“å…¥æ‚¨çš„ç ”ç©¶æ„æƒ³...">æˆ‘æƒ³ç ”ç©¶è›‹ç™½è´¨Xå’Œç–¾ç—…Yä¹‹é—´çš„å…³ç³»ï¼Œç‰¹åˆ«å…³æ³¨å…¶åœ¨ç»†èƒä¿¡å·é€šè·¯ä¸­çš„ä½œç”¨æœºåˆ¶ã€‚</textarea>
                        </div>
                        <div>
                            <h3 class="text-md font-medium text-gray-700 mb-2">æ¨¡å‹é€‰æ‹©</h3>
                            <div class="space-y-3">
                                <div>
                                    <label for="mainLlm" class="block text-sm text-gray-600">æ ¸å¿ƒæ¨¡å‹ (ç”¨äºåˆ›ä½œå’Œåˆ†æ)</label>
                                    <select id="mainLlm" class="w-full mt-1 px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
                                </div>
                                <div>
                                    <label for="knowledgeLlm" class="block text-sm text-gray-600">çŸ¥è¯†æ¨¡å‹ (ç”¨äºæ–‡çŒ®ç»¼è¿°)</label>
                                    <select id="knowledgeLlm" class="w-full mt-1 px-3 py-2 bg-gray-50 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
                                </div>
                            </div>
                        </div>
                        <div class="space-y-3">
                            <h3 class="text-md font-medium text-gray-700">çŸ¥è¯†åº“ç®¡ç†</h3>
                            <div>
                                <label for="fileUpload" class="block text-sm text-gray-600 mb-1">ä¸Šä¼ æ–‡ä»¶ (txt, md, pdf)</label>
                                <input type="file" id="fileUpload" multiple accept=".txt,.md,.text,.pdf" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                            </div>
                            <div id="knowledgeBaseStatus" class="text-xs text-gray-500 p-2 bg-gray-100 rounded-md">çŸ¥è¯†åº“ä¸ºç©ºã€‚</div>
                            <button id="clearKnowledgeBase" class="w-full text-sm bg-red-500 text-white font-semibold py-2 px-4 rounded-lg shadow-sm hover:bg-red-600">æ¸…é™¤çŸ¥è¯†åº“</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Outputs -->
            <div class="lg:col-span-3 bg-white p-6 rounded-2xl shadow-lg border border-gray-200">
                <!-- MOVED: Workflow Control Panel -->
                <div id="control-panel" class="control-panel space-y-3 pb-6 mb-6 border-b-2 border-dashed">
                     <h2 class="text-xl font-semibold">å·¥ä½œæµç¨‹æ§åˆ¶</h2>
                     <button id="workflowButton" class="w-full bg-blue-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-blue-700 flex items-center justify-center">
                        <span id="buttonText">å¼€å§‹æµç¨‹</span>
                        <div id="loader" class="loader hidden ml-3"></div>
                    </button>
                    <div id="revision-controls" class="hidden space-y-3">
                        <h3 class="text-md font-semibold text-center text-orange-600">è¿›å…¥ä¿®è®¢æ¨¡å¼</h3>
                        <p class="text-sm text-gray-600">æ‚¨ç°åœ¨å¯ä»¥ç›´æ¥åœ¨ä¸‹æ–¹æŠ¥å‘ŠåŒºä¿®æ”¹è‰ç¨¿ã€‚å®Œæˆåï¼Œå¯å¤šæ¬¡ç‚¹å‡»â€œä¼˜åŒ–â€è¿›è¡Œè¿­ä»£ï¼Œæˆ–åœ¨æ»¡æ„åç‚¹å‡»â€œå®Œæˆâ€ç»§ç»­ä¸‹ä¸€æ­¥ã€‚</p>
                        <button id="reviseButton" class="w-full bg-orange-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-orange-600">è¿­ä»£ä¼˜åŒ–å½“å‰è‰ç¨¿</button>
                        <button id="finishRevisionButton" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-green-700">å®Œæˆä¿®è®¢ï¼Œç»§ç»­ç”Ÿæˆç»ˆç¨¿</button>
                    </div>
                </div>

                <!-- Tab Navigation -->
                <div class="border-b border-gray-200">
                    <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                        <button class="tab-btn active whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm" data-tab="report">æŠ¥å‘Š/ç¼–è¾‘åŒº</button>
                        <button class="tab-btn whitespace-nowrap py-3 px-1 border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 font-medium text-sm" data-tab="prompts">Prompts</button>
                        <button class="tab-btn whitespace-nowrap py-3 px-1 border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 font-medium text-sm" data-tab="logs">æ‰§è¡Œæ—¥å¿—</button>
                        <button class="tab-btn whitespace-nowrap py-3 px-1 border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 font-medium text-sm" data-tab="roadmap">æŠ€æœ¯è·¯çº¿å›¾</button>
                    </nav>
                </div>

                <!-- Tab Content -->
                <div class="mt-6">
                    <div class="tab-content" id="tab-report">
                        <div id="reportOutput" class="prose max-w-none h-[65vh] overflow-y-auto bg-gray-50 p-4 rounded-lg border border-gray-200">æŠ¥å‘Šå†…å®¹å°†åœ¨æ­¤å¤„æ˜¾ç¤ºã€‚</div>
                    </div>
                    <div class="tab-content hidden" id="tab-prompts">
                        <div id="promptsContainer" class="space-y-4 h-[65vh] overflow-y-auto"></div>
                    </div>
                    <div class="tab-content hidden" id="tab-logs">
                        <div id="logOutput" class="h-[65vh] bg-gray-900 text-white font-mono text-sm p-4 rounded-lg overflow-y-auto border border-gray-700">è¯·å…ˆé…ç½®å‚æ•°å¹¶ç‚¹å‡»â€œå¼€å§‹æµç¨‹â€...</div>
                    </div>
                    <div class="tab-content hidden" id="tab-roadmap">
                        <div id="roadmapOutput" class="w-full h-[65vh] overflow-auto bg-gray-50 p-4 rounded-lg border border-gray-200 flex justify-center items-center"></div>
                    </div>
                </div>
            </div>
        </div>
        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>ç”±å¤šæ¨¡å‹AIé©±åŠ¨çš„å‰ç«¯åº”ç”¨</p>
        </footer>
    </div>

    <script type="module">
        import * as pdfjsLib from "https://mozilla.github.io/pdf.js/build/pdf.mjs";
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://mozilla.github.io/pdf.js/build/pdf.worker.mjs`;

        const PROMPTS = {
            clarify_objectives: `##Role:\nI am a professor in the field of [FIELD], with many years of deep cultivation in this field, and I have a wealth of academic knowledge and research experience. I am proficient in Chinese writing, grammar rules and format specifications, and I am good at writing grant proposals for research funds.\n\n##Goals:\nAccording to the user's topic selection, help them write the "research content, research objectives, and key scientific issues to be solved" part of the fund application, and fully reflect the innovation and feasibility of the project, so as to get the approval of review experts.`,
            literature_review: `##Role:\nI am a professor in the field of [FIELD].\n\n##Goals:\nAccording to the user's topic selection AND the provided knowledge base, help them write the "Basis for Project Establishment" part. Fully reflect the scientificity, innovation and necessity of the project.`,
            research_plan: `##Role:\nI am a professor in the field of [FIELD].\n\n##Goals:\nAccording to the user's topic selection, help them write the "Proposed Research Plan and Feasibility Analysis" part.`,
            innovation: `##Role:\nI am a professor in the field of [FIELD].\n\n##Goals:\nHelp them write the "Features and Innovations of this Project" part.`,
            reviser: `##Role:\nI am an expert editor. My goal is to revise the provided drafts based on the user's direct edits and the AI reviewer's feedback. I will integrate the suggestions to produce a more polished and coherent version. I will output the complete, revised text for all sections that were modified.\n\n## AI Reviewer Feedback:\n[REVIEW_FEEDBACK]\n\n## User's Revised Drafts:\n[USER_DRAFTS]`,
            reviewer: `##Role:\nI am a professor in the field of [FIELD] and an experienced fund review expert.\n\n##Goals:\nFor the user's Chinese grant proposal draft, as a fund review expert, I will help with the pre-review, point out the problems and improvement suggestions of each part of the application.`,
            title_abstract: `##Role:\nI am a professor in the field of [FIELD].\n\n##Goals:\nFormulate the "title" and "abstract" of the fund application. Your output MUST be a JSON object with two keys: "title" and "abstract".`,
            technical_roadmap: `##Role:\nI am a professor in the field of [FIELD], specializing in creating clear, professional technical roadmaps for grant proposals.\n\n##Goals:\nBased on the provided final research content, generate a technical roadmap. The roadmap should be structured logically, highlighting key stages, methods, and expected outcomes to demonstrate the project's feasibility and innovation.\n\n##Requirements:\n- The output must be a single, complete SVG code block. Do not wrap it in HTML or markdown.\n- The SVG should be visually clean, using simple shapes (rectangles, arrows) and a clear hierarchy.\n- Use a professional, low-saturation color scheme.\n- Ensure text is legible and fits within the shapes.\n- The overall structure should logically flow from the research objectives to the final outcome.\n\n##Final Research Content:\n[RESEARCH_CONTENT]`
        };

        let graphState = {};
        let currentStep = 0;
        let researchField = 'é€šç”¨é¢†åŸŸ';

        const elements = {
            // Existing elements
            apiKey: document.getElementById('apiKey'),
            apiBaseUrl: document.getElementById('apiBaseUrl'),
            initialPrompt: document.getElementById('initialPrompt'),
            // New elements for provider selection
            apiProvider: document.getElementById('apiProvider'),
            apiKeyLabel: document.getElementById('apiKeyLabel'),
            apiBaseUrlContainer: document.getElementById('apiBaseUrlContainer'),
            apiBaseUrlLabel: document.getElementById('apiBaseUrlLabel'),
            fetchModelsButton: document.getElementById('fetchModelsButton'),
            connectivityStatus: document.getElementById('connectivityStatus'),
            // Continuing existing elements
            mainLlm: document.getElementById('mainLlm'),
            knowledgeLlm: document.getElementById('knowledgeLlm'),
            workflowButton: document.getElementById('workflowButton'),
            logOutput: document.getElementById('logOutput'),
            reportOutput: document.getElementById('reportOutput'),
            loader: document.getElementById('loader'),
            buttonText: document.getElementById('buttonText'),
            fileUpload: document.getElementById('fileUpload'),
            knowledgeBaseStatus: document.getElementById('knowledgeBaseStatus'),
            clearKnowledgeBase: document.getElementById('clearKnowledgeBase'),
            promptsContainer: document.getElementById('promptsContainer'),
            revisionControls: document.getElementById('revision-controls'),
            reviseButton: document.getElementById('reviseButton'),
            finishRevisionButton: document.getElementById('finishRevisionButton'),
            // roadmapContainer was unused and the ID did not exist in HTML.
            roadmapOutput: document.getElementById('roadmapOutput'),
            tabButtons: document.querySelectorAll('.tab-btn'),
            tabContents: document.querySelectorAll('.tab-content'),
        };

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            elements.logOutput.innerHTML += `<div><span class="text-gray-500">${timestamp}</span>: <span class="text-green-400">${message}</span></div>`;
            elements.logOutput.scrollTop = elements.logOutput.scrollHeight;
        }
        function logError(message) {
            const timestamp = new Date().toLocaleTimeString();
            elements.logOutput.innerHTML += `<div><span class="text-gray-500">${timestamp}</span>: <span class="text-red-400">${message}</span></div>`;
            elements.logOutput.scrollTop = elements.logOutput.scrollHeight;
        }
        function toggleLoading(isLoading, text = 'å¼€å§‹æµç¨‹') {
            elements.workflowButton.disabled = isLoading;
            elements.buttonText.textContent = isLoading ? 'AIæ­£åœ¨å·¥ä½œä¸­...' : text;
            elements.loader.classList.toggle('hidden', !isLoading);
        }

        async function callLlm(prompt, modelName, apiKey, apiBaseUrl) {
            let endpoint = '';
            let headers = { 'Content-Type': 'application/json' };
            let body = {};

            if (modelName.startsWith('gemini-') && !apiBaseUrl) {
                endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
                body = { contents: [{ parts: [{ text: prompt }] }] };
            } else {
                // This path is taken if modelName is not 'gemini-' OR if apiBaseUrl is provided.
                // If apiBaseUrl is NOT provided here, it means a non-Gemini model was chosen without a required Base URL.
                if (!apiBaseUrl) throw new Error("æ­¤æ¨¡å‹é…ç½®éœ€è¦ API Base URLï¼Œä½†æœªæä¾›ã€‚");
                endpoint = `${apiBaseUrl.replace(/\/$/, '')}/chat/completions`;
                headers['Authorization'] = `Bearer ${apiKey}`;
                body = { model: modelName, messages: [{ role: 'user', content: prompt }] };
            }

            try {
                const response = await fetch(endpoint, { method: 'POST', headers, body: JSON.stringify(body) });
                if (!response.ok) {
                    let errorDataMessage = `HTTP status ${response.status}`;
                    try {
                        const errorData = await response.json();
                        // Attempt to extract a meaningful message from various possible error structures
                        errorDataMessage = errorData?.error?.message || // Standard OpenAI, Google, some OpenRouter
                                         errorData?.error?.type ||    // Some OpenRouter (e.g., Anthropic)
                                         errorData?.message ||        // Direct message property
                                         JSON.stringify(errorData);   // Fallback to stringifying the whole error object
                    } catch (e) {
                        // If response body isn't JSON or JSON parsing fails
                        try {
                            const errorText = await response.text();
                            errorDataMessage = `${response.statusText || 'Error'}: ${errorText || '(No further error details in response body)'}`;
                        } catch (textErr) {
                             // Fallback if reading response.text() also fails
                             errorDataMessage = `${response.statusText || 'Error'} (Could not parse error response body and failed to read as text)`;
                        }
                    }
                    throw new Error(`API Error (${modelName}): ${response.status} - ${errorDataMessage}`);
                }
                const data = await response.json(); // Assuming response.ok means data is valid JSON

                if (modelName.startsWith('gemini-') && !apiBaseUrl) { // Native Gemini call
                    const textContent = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (typeof textContent === 'undefined') {
                        logError(`Gemini API (${modelName}) returned a 200 OK but the expected content is missing. Full response: ${JSON.stringify(data)}`);
                        if (data.promptFeedback && data.promptFeedback.blockReason) {
                             throw new Error(`Gemini API request to ${modelName} was blocked due to: ${data.promptFeedback.blockReason}. Safety ratings: ${JSON.stringify(data.promptFeedback.safetyRatings)}`);
                        }
                        throw new Error(`Gemini API call to ${modelName} was successful (200 OK) but no valid content was found in the response.`);
                    }
                    return textContent;
                } else { // OpenAI-compatible or other proxied models
                    const messageContent = data.choices?.[0]?.message?.content;
                    if (typeof messageContent === 'undefined') {
                        logError(`Compatible API (${modelName}) returned a 200 OK but the expected content (choices[0].message.content) is missing. Full response: ${JSON.stringify(data)}`);
                        if (data.choices && data.choices.length > 0 && data.choices[0].finish_reason) {
                            throw new Error(`Compatible API call to ${modelName} (200 OK) finished with reason '${data.choices[0].finish_reason}' but no content was returned.`);
                        }
                        if (data.error) { // Some APIs might return 200 OK with an error object in the body
                             throw new Error(`Compatible API call to ${modelName} (200 OK) returned an error object in the response body: ${data.error.message || JSON.stringify(data.error)}`);
                        }
                        throw new Error(`Compatible API call to ${modelName} was successful (200 OK) but no valid content was found in the response.`);
                    }
                    return messageContent;
                }
            } catch (error) {
                // This catches:
                // 1. Network errors from fetch itself (e.g., DNS failure, server unreachable).
                // 2. Errors from response.json() if the response body isn't valid JSON (e.g. HTML error page).
                // 3. Errors explicitly thrown from the blocks above (e.g., !response.ok, missing content).
                const originalErrorMessage = error.message;
                // Add modelName to the error if not already present for easier debugging from logs.
                const finalErrorMessage = originalErrorMessage.includes(modelName) ? originalErrorMessage : `Model call failed for ${modelName}: ${originalErrorMessage}`;
                logError(finalErrorMessage); // Log the detailed error.
                throw new Error(finalErrorMessage); // Re-throw to be caught by runWorkflow.
            }
        }

        function getPromptWithState(promptText, state, knowledgeBaseContent) {
            let finalPrompt = promptText;
            if (knowledgeBaseContent) {
                finalPrompt = `Please refer to the following knowledge base content:\n\n<knowledge_base>\n${knowledgeBaseContent}\n</knowledge_base>\n\nAnd now, follow these instructions:\n${finalPrompt}`;
            }
            return `${finalPrompt}\n\n## Current Project State:\n${JSON.stringify(state, null, 2)}`;
        }

        function updateReportOutput(content, isEditable = false) {
            if (isEditable) {
                elements.reportOutput.innerHTML = `<textarea id="editor" class="w-full h-full bg-yellow-50 border-2 border-yellow-400 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-yellow-500">${content}</textarea>`;
            } else {
                elements.reportOutput.innerHTML = marked.parse(content.replace(/\n/g, '<br>'));
            }
        }

        function updateKnowledgeBaseStatus(content) {
            const sizeInKB = content ? (content.length / 1024).toFixed(2) : 0;
            elements.knowledgeBaseStatus.textContent = content ? `çŸ¥è¯†åº“å·²åŠ è½½ (${sizeInKB} KB)ã€‚` : 'çŸ¥è¯†åº“ä¸ºç©ºã€‚';
            elements.knowledgeBaseStatus.classList.toggle('text-green-600', !!content);
            elements.knowledgeBaseStatus.classList.toggle('text-gray-500', !content);
        }

        elements.fileUpload.addEventListener('change', async (event) => {
            const files = event.target.files;
            if (!files.length) return;
            let combinedText = localStorage.getItem('knowledgeBase') || '';
            log(`æ­£åœ¨åŠ è½½ ${files.length} ä¸ªæ–‡ä»¶...`);
            for (const file of Array.from(files)) {
                try {
                    const text = file.type === 'application/pdf' ? await parsePdf(file) : await file.text();
                    combinedText += text + '\n\n---\n\n';
                    log(`âœ… æ–‡ä»¶ ${file.name} åŠ è½½æˆåŠŸã€‚`);
                } catch (e) {
                    logError(`å¤„ç†æ–‡ä»¶ ${file.name} å¤±è´¥: ${e.message}`);
                }
            }
            try {
                localStorage.setItem('knowledgeBase', combinedText);
                updateKnowledgeBaseStatus(combinedText);
            } catch (e) {
                logError(`å­˜å‚¨çŸ¥è¯†åº“å¤±è´¥ (Failed to save knowledge base): ${e.message}. å¯èƒ½å·²è¶…å‡ºæµè§ˆå™¨å­˜å‚¨é™åˆ¶ã€‚`);
                // Optionally, revert to previous state or clear if appropriate
                // For now, just log the error. The UI might be out of sync if this fails.
            }
        });

        async function parsePdf(file) {
            const loadingTask = pdfjsLib.getDocument(URL.createObjectURL(file));
            const pdf = await loadingTask.promise;
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                fullText += textContent.items.map(s => s.str).join(' ') + '\n';
            }
            return fullText;
        }

        elements.clearKnowledgeBase.addEventListener('click', () => {
            localStorage.removeItem('knowledgeBase');
            updateKnowledgeBaseStatus(null);
            log('çŸ¥è¯†åº“å·²æ¸…é™¤ã€‚');
        });

        function populatePrompts() {
            elements.promptsContainer.innerHTML = '';
            for (const key in PROMPTS) {
                const promptDiv = document.createElement('div');
                promptDiv.innerHTML = `
                    <label for="prompt-${key}" class="block text-sm font-medium text-gray-700 mb-1">${key}</label>
                    <textarea id="prompt-${key}" class="w-full px-3 py-2 bg-white border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" rows="8">${PROMPTS[key]}</textarea>
                `;
                elements.promptsContainer.appendChild(promptDiv);
            }
        }

        function getCurrentPrompts() {
            const currentPrompts = {};
            for (const key in PROMPTS) {
                currentPrompts[key] = document.getElementById(`prompt-${key}`).value.replace(/\[FIELD\]/g, researchField.trim());
            }
            return currentPrompts;
        }

        const defaultModels = {
            main: [
                { group: "Google Gemini (åŸç”Ÿ)", models: ["gemini-1.5-pro-latest", "gemini-1.5-flash-latest"] },
                { group: "OpenAI (é€šè¿‡ OpenRouter)", models: ["openai/gpt-4o"] },
                { group: "Anthropic (é€šè¿‡ OpenRouter)", models: ["anthropic/claude-3.5-sonnet", "anthropic/claude-3-opus"] },
                { group: "Meta (é€šè¿‡ OpenRouter)", models: ["meta-llama/llama-3.1-405b-instruct"] },
                { group: "ç¡…åŸºæµåŠ¨ (Moonshot AI)", models: ["moonshot-v1-8k", "moonshot-v1-32k", "moonshot-v1-128k"] }
            ],
            knowledge: [
                { group: "Google Gemini (åŸç”Ÿ)", models: ["gemini-1.5-flash-latest"] },
                { group: "OpenRouter (ç»æµå‹)", models: ["anthropic/claude-3-haiku", "mistralai/mistral-7b-instruct"] },
                { group: "ç¡…åŸºæµåŠ¨ (Moonshot AI)", models: ["moonshot-v1-8k"] }
            ]
        };

        function populateModelSelect(selectElement, modelGroups) {
            selectElement.innerHTML = ''; // Clear existing options first
            if (!modelGroups || modelGroups.length === 0) {
                selectElement.innerHTML = '<option value="">æ— å¯ç”¨æ¨¡å‹</option>';
                return;
            }
            modelGroups.forEach(group => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = group.group;
                group.models.forEach(modelId => {
                    const option = document.createElement('option');
                    option.value = modelId;
                    option.textContent = modelId.split('/').pop(); // Display cleaner name
                    optgroup.appendChild(option);
                });
                selectElement.appendChild(optgroup);
            });
             if (selectElement.options.length === 0) { // Should not happen if modelGroups is not empty, but as a safeguard
                selectElement.innerHTML = '<option value="">æ— å¯ç”¨æ¨¡å‹</option>';
            }
        }

        // fetchAndUpdateModels function is now removed as its functionality is superseded by handleFetchModels.

        // elements.apiBaseUrl.addEventListener('blur', fetchAndUpdateModels); // This event listener is removed.

        function updateProviderUI() {
            const selectedProvider = elements.apiProvider.value;

            // Clear model lists and status
            const placeholderOption = '<option value="">è¯·å…ˆè¿æ¥å¹¶è·å–æ¨¡å‹</option>';
            elements.mainLlm.innerHTML = placeholderOption;
            elements.knowledgeLlm.innerHTML = placeholderOption;
            elements.connectivityStatus.textContent = '';

            switch (selectedProvider) {
                case 'gemini_native':
                    elements.apiKeyLabel.textContent = 'Google API Key:';
                    elements.apiKey.placeholder = 'è¾“å…¥æ‚¨çš„ Google API å¯†é’¥';
                    elements.apiBaseUrlContainer.classList.add('hidden');
                    elements.apiBaseUrl.value = ''; // Clear any previous value
                    break;
                case 'openrouter':
                    elements.apiKeyLabel.textContent = 'OpenRouter API Key:';
                    elements.apiKey.placeholder = 'è¾“å…¥æ‚¨çš„ OpenRouter API å¯†é’¥ (sk-or-...)';
                    elements.apiBaseUrlContainer.classList.remove('hidden');
                    elements.apiBaseUrlLabel.textContent = 'OpenRouter API Base URL:';
                    elements.apiBaseUrl.value = 'https://openrouter.ai/api/v1';
                    elements.apiBaseUrl.placeholder = 'https://openrouter.ai/api/v1';
                    break;
                case 'openai_compatible':
                    elements.apiKeyLabel.textContent = 'API Key (å¯é€‰):';
                    elements.apiKey.placeholder = 'å¦‚æœéœ€è¦ï¼Œè¯·è¾“å…¥API Key';
                    elements.apiBaseUrlContainer.classList.remove('hidden');
                    elements.apiBaseUrlLabel.textContent = 'å…¼å®¹ API Base URL:';
                    elements.apiBaseUrl.value = '';
                    elements.apiBaseUrl.placeholder = 'ä¾‹å¦‚: http://localhost:1234/v1';
                    break;
                case 'custom':
                    elements.apiKeyLabel.textContent = 'API Key:';
                    elements.apiKey.placeholder = 'è¾“å…¥æ‚¨çš„ API Key';
                    elements.apiBaseUrlContainer.classList.remove('hidden');
                    elements.apiBaseUrlLabel.textContent = 'è‡ªå®šä¹‰ API Base URL:';
                    elements.apiBaseUrl.value = '';
                    elements.apiBaseUrl.placeholder = 'è¾“å…¥å®Œæ•´çš„ API Base URL';
                    break;
                default:
                    elements.apiKeyLabel.textContent = 'API Key:';
                    elements.apiBaseUrlContainer.classList.add('hidden');
            }
        }

        elements.apiProvider.addEventListener('change', updateProviderUI);

        async function handleFetchModels() {
            const provider = elements.apiProvider.value;
            const apiKey = elements.apiKey.value.trim();
            const apiBaseUrl = elements.apiBaseUrl.value.trim();

            elements.connectivityStatus.textContent = 'æ­£åœ¨æ£€æŸ¥è¿æ¥å¹¶è·å–æ¨¡å‹...';
            elements.connectivityStatus.classList.remove('text-red-500', 'text-green-500');
            elements.connectivityStatus.classList.add('text-blue-500');

            // Clear previous models
            elements.mainLlm.innerHTML = '<option value="">è·å–ä¸­...</option>';
            elements.knowledgeLlm.innerHTML = '<option value="">è·å–ä¸­...</option>';

            try {
                let fetchedModels = [];
                let modelGroups = [];

                switch (provider) {
                    case 'gemini_native':
                        if (!apiKey) {
                            throw new Error("Google API Key æœªæä¾›ã€‚");
                        }
                        // For native Gemini, we don't fetch from an endpoint, we use predefined defaults.
                        // Filter defaultModels for Gemini entries.
                        const geminiMainModels = defaultModels.main.find(group => group.group.toLowerCase().includes("gemini"));
                        const geminiKnowledgeModels = defaultModels.knowledge.find(group => group.group.toLowerCase().includes("gemini"));

                        if (geminiMainModels) modelGroups.push(geminiMainModels);
                        // Add other default groups too, or just Gemini? For now, let's assume only Gemini for this provider.
                        populateModelSelect(elements.mainLlm, geminiMainModels ? [geminiMainModels] : []);
                        populateModelSelect(elements.knowledgeLlm, geminiKnowledgeModels ? [geminiKnowledgeModels] : []);

                        elements.connectivityStatus.textContent = 'å·²é€‰æ‹© Gemini (åŸç”Ÿ)ã€‚é»˜è®¤æ¨¡å‹å·²åŠ è½½ã€‚';
                        elements.connectivityStatus.classList.add('text-green-500');
                        return; // Exit early

                    case 'openrouter':
                    case 'openai_compatible':
                    case 'custom':
                        if (!apiBaseUrl) {
                            throw new Error("API Base URL æœªæä¾›ã€‚");
                        }
                        // For OpenRouter and OpenAI compatible, API key might be optional for some local LLMs
                        if ((provider === 'openrouter' || provider === 'custom') && !apiKey) {
                             // OpenRouter and typically custom setups would require an API key.
                            throw new Error("API Key æœªæä¾›ã€‚");
                        }

                        const modelsUrl = `${apiBaseUrl.replace(/\/$/, '')}/models`;
                        const headers = { 'Authorization': `Bearer ${apiKey}` };

                        const response = await fetch(modelsUrl, apiKey ? { headers } : {}); // Don't send auth header if no API key (for truly open local LLMs)

                        if (!response.ok) {
                            const errorData = await response.text();
                            throw new Error(`è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥: ${response.status} - ${errorData}`);
                        }
                        const data = await response.json();
                        // Standard OpenAI format is data.data, OpenRouter also uses data.data
                        if (data && data.data && Array.isArray(data.data)) {
                            fetchedModels = data.data.map(m => m.id).sort();
                        } else {
                            // Fallback for non-standard list, e.g. some local LLMs might return a flat list or { "models": [] }
                            // This part might need adjustment based on actual non-standard API responses.
                            // For now, we'll assume it's an array of strings if not data.data
                            if (Array.isArray(data)) { // Simple list of strings
                                fetchedModels = data.map(m => typeof m === 'string' ? m : m.id).sort();
                            } else if (data.models && Array.isArray(data.models)){ // like { models: ["id1", "id2"]}
                                fetchedModels = data.models.map(m => typeof m === 'string' ? m : m.id).sort();
                            } else {
                                console.warn("Model list response format not standard OpenAI. Full response:", data);
                                throw new Error("è·å–åˆ°çš„æ¨¡å‹åˆ—è¡¨æ ¼å¼ä¸è¯†åˆ«ã€‚è¯·æ£€æŸ¥APIå“åº”ã€‚");
                            }
                        }

                        if (fetchedModels.length === 0) {
                           throw new Error("APIè¿”å›äº†ç©ºæ¨¡å‹åˆ—è¡¨ã€‚");
                        }

                        modelGroups = [{ group: `æ¥è‡ª ${provider} çš„æ¨¡å‹`, models: fetchedModels }];
                        populateModelSelect(elements.mainLlm, modelGroups);
                        populateModelSelect(elements.knowledgeLlm, modelGroups);
                        elements.connectivityStatus.textContent = `è¿æ¥æˆåŠŸï¼è·å–äº† ${fetchedModels.length} ä¸ªæ¨¡å‹ã€‚`;
                        elements.connectivityStatus.classList.add('text-green-500');
                        break;
                    default:
                        throw new Error("æœªçŸ¥çš„APIæä¾›å•†ã€‚");
                }
            } catch (error) {
                logError(error.message);
                elements.connectivityStatus.textContent = `é”™è¯¯: ${error.message}`;
                elements.connectivityStatus.classList.add('text-red-500');
                // Fallback to default models on error
                populateModelSelect(elements.mainLlm, defaultModels.main);
                populateModelSelect(elements.knowledgeLlm, defaultModels.knowledge);
            } finally {
                 elements.connectivityStatus.classList.remove('text-blue-500');
            }
        }

        elements.fetchModelsButton.addEventListener('click', handleFetchModels);

        elements.tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                elements.tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                elements.tabContents.forEach(content => content.classList.add('hidden'));
                document.getElementById(`tab-${button.dataset.tab}`).classList.remove('hidden');
            });
        });

        const workflowSteps = [
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("æ­¥éª¤ 0: è¯†åˆ«ç ”ç©¶é¢†åŸŸ...");
                const fieldPrompt = `From the following research idea, extract the primary academic field in 1-3 words. For example, for "æˆ‘æƒ³ç ”ç©¶è›‹ç™½è´¨Xå’Œç–¾ç—…Yä¹‹é—´çš„å…³ç³»...", the field is "åˆ†å­ç”Ÿç‰©å­¦". Research Idea: "${elements.initialPrompt.value}". Field:`;
                researchField = await callLlm(fieldPrompt, mainLlm, apiKey, apiBaseUrl);
                log(`âœ… è¯†åˆ«é¢†åŸŸä¸º: ${researchField.trim()}`);
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("æ­¥éª¤ 1: æ‰§è¡Œ 'ç›®æ ‡æ¾„æ¸…'...");
                const prompt = getPromptWithState(getCurrentPrompts().clarify_objectives, { initial_prompt: graphState.initial_prompt });
                graphState.clarified_objectives = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                updateReportOutput(`### ç›®æ ‡ã€å†…å®¹ä¸å…³é”®ç§‘å­¦é—®é¢˜\n\n${graphState.clarified_objectives}`);
                log("âœ… 'ç›®æ ‡æ¾„æ¸…' å®Œæˆã€‚è¯·ç¡®è®¤åç»§ç»­ã€‚");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("æ­¥éª¤ 2: æ‰§è¡Œ 'æ–‡çŒ®ç»¼è¿°'...");
                const prompt = getPromptWithState(getCurrentPrompts().literature_review, graphState, localStorage.getItem('knowledgeBase'));
                graphState.literature_review_draft = await callLlm(prompt, knowledgeLlm, apiKey, apiBaseUrl);
                updateReportOutput(`### ç«‹è®ºä¾æ® (æ–‡çŒ®ç»¼è¿°)\n\n${graphState.literature_review_draft}`);
                log("âœ… 'æ–‡çŒ®ç»¼è¿°' å®Œæˆã€‚è¯·ç¡®è®¤åç»§ç»­ã€‚");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("æ­¥éª¤ 3: æ‰§è¡Œ 'ç ”ç©¶è®¡åˆ’'...");
                const prompt = getPromptWithState(getCurrentPrompts().research_plan, graphState);
                graphState.research_plan_draft = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                updateReportOutput(`### ç ”ç©¶æ–¹æ¡ˆ\n\n${graphState.research_plan_draft}`);
                log("âœ… 'ç ”ç©¶è®¡åˆ’' å®Œæˆã€‚è¯·ç¡®è®¤åç»§ç»­ã€‚");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("æ­¥éª¤ 4: æ‰§è¡Œ 'åˆ›æ–°ç‚¹'...");
                const prompt = getPromptWithState(getCurrentPrompts().innovation, graphState);
                graphState.innovation_draft = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                updateReportOutput(`### æœ¬é¡¹ç›®çš„ç‰¹è‰²ä¸åˆ›æ–°ä¹‹å¤„\n\n${graphState.innovation_draft}`);
                log("âœ… 'åˆ›æ–°ç‚¹' å®Œæˆã€‚è¯·ç¡®è®¤åç»§ç»­ã€‚");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("æ­¥éª¤ 5: æ‰§è¡Œ 'AIè¯„å®¡'...");
                const fullDraft = `ç«‹è®ºä¾æ®:\n${graphState.literature_review_draft}\n\nç ”ç©¶æ–¹æ¡ˆ:\n${graphState.research_plan_draft}\n\nåˆ›æ–°ä¹‹å¤„:\n${graphState.innovation_draft}`;
                const prompt = getPromptWithState(getCurrentPrompts().reviewer, { full_draft: fullDraft });
                graphState.review_feedback = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                const combinedReport = `${fullDraft}\n\n---\n\n### AI è¯„å®¡å‘˜æ„è§\n\n${graphState.review_feedback}`;
                updateReportOutput(combinedReport, true);
                log("âœ… 'AIè¯„å®¡' å®Œæˆã€‚è¯·ç›´æ¥ä¿®æ”¹ä¸Šæ–¹è‰ç¨¿ï¼Œç„¶åç‚¹å‡»â€œæäº¤ä¿®æ”¹å¹¶å¯åŠ¨ä¼˜åŒ–â€ã€‚");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("æ­¥éª¤ 6: æ‰§è¡Œ 'ä¿®è®¢ä¼˜åŒ–'...");
                const userDrafts = document.getElementById('editor').value;
                let prompt = getCurrentPrompts().reviser.replace('[REVIEW_FEEDBACK]', graphState.review_feedback).replace('[USER_DRAFTS]', userDrafts);
                const revisedText = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                graphState.literature_review_draft = revisedText;
                graphState.research_plan_draft = '';
                graphState.innovation_draft = '';
                updateReportOutput(`### ä¿®è®¢åç‰ˆæœ¬\n\n${revisedText}`, true); // Keep it editable
                log("âœ… 'ä¿®è®¢ä¼˜åŒ–' å®Œæˆã€‚æ‚¨å¯ä»¥ç»§ç»­ä¿®æ”¹å¹¶ä¼˜åŒ–ï¼Œæˆ–ç‚¹å‡»â€œå®Œæˆä¿®è®¢â€ã€‚");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("æ­¥éª¤ 7: æ‰§è¡Œ 'æ ‡é¢˜å’Œæ‘˜è¦'...");
                const prompt = getPromptWithState(getCurrentPrompts().title_abstract, graphState);
                const jsonStr = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                try {
                    let contentToParse = jsonStr.trim();
                    const jsonMatch = contentToParse.match(/```json\n([\s\S]*?)\n```/);

                    if (jsonMatch && jsonMatch[1]) {
                        contentToParse = jsonMatch[1].trim();
                    } else if (contentToParse.startsWith('{') && contentToParse.endsWith('}')) {
                        // Content already looks like a raw JSON object, use as is.
                    } else {
                        // Output is neither a recognized JSON markdown block nor a string that looks like a JSON object.
                        throw new Error("LLM output for title/abstract was not in the expected JSON format or a JSON markdown block.");
                    }

                    const parsed = JSON.parse(contentToParse);

                    if (parsed && typeof parsed.title === 'string' && typeof parsed.abstract === 'string') {
                        graphState.final_title = parsed.title;
                        graphState.final_abstract = parsed.abstract;
                    } else {
                        throw new Error("Parsed JSON for title/abstract does not contain valid 'title' (string) and 'abstract' (string) properties.");
                    }
                } catch(e) {
                    logError(`æ ‡é¢˜/æ‘˜è¦JSONè§£æå¤±è´¥ (Title/Abstract JSON parsing failed): ${e.message}. Raw LLM output was: "${jsonStr}"`);
                    graphState.final_title = "æ ‡é¢˜ç”Ÿæˆå¤±è´¥";
                    graphState.final_abstract = "æ‘˜è¦ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‰§è¡Œæ—¥å¿—ä¸­çš„åŸå§‹è¾“å‡ºã€‚";
                }
                updateReportOutput(`<h2>${graphState.final_title}</h2>\n\n<h3>æ‘˜è¦</h3>\n\n<p>${graphState.final_abstract}</p>`);
                log("âœ… 'æ ‡é¢˜å’Œæ‘˜è¦' å®Œæˆã€‚è¯·ç¡®è®¤åç»§ç»­ã€‚");
            },
            async (apiKey, mainLlm, knowledgeLlm, apiBaseUrl) => {
                log("æ­¥éª¤ 8: æ‰§è¡Œ 'æŠ€æœ¯è·¯çº¿å›¾'...");
                document.querySelector('[data-tab="roadmap"]').click();
                // After revision steps (6 and user finalization), graphState.literature_review_draft
                // is expected to hold the complete revised body of the proposal.
                // graphState.research_plan_draft and graphState.innovation_draft are cleared at that stage.
                // So, the technical roadmap should be based on the consolidated content in graphState.literature_review_draft.
                const researchContent = graphState.literature_review_draft;
                let prompt = getCurrentPrompts().technical_roadmap.replace('[RESEARCH_CONTENT]', researchContent);
                const svgCode = await callLlm(prompt, mainLlm, apiKey, apiBaseUrl);
                elements.roadmapOutput.innerHTML = svgCode;
                log("âœ… 'æŠ€æœ¯è·¯çº¿å›¾' å®Œæˆã€‚");
            }
        ];

        async function runWorkflow() {
            const { apiKey, mainLlm, knowledgeLlm, apiBaseUrl } = {
                apiKey: elements.apiKey.value.trim(),
                mainLlm: elements.mainLlm.value,
                knowledgeLlm: elements.knowledgeLlm.value,
                apiBaseUrl: elements.apiBaseUrl.value.trim()
            };

            if (!apiKey || (!elements.initialPrompt.value.trim() && currentStep === 0)) {
                logError("é”™è¯¯ï¼šAPIå¯†é’¥å’Œç ”ç©¶æ„æƒ³ä¸èƒ½ä¸ºç©ºã€‚");
                return;
            }

            toggleLoading(true, 'ç¡®è®¤å¹¶ç»§ç»­');

            try {
                await workflowSteps[currentStep](apiKey, mainLlm, knowledgeLlm, apiBaseUrl);

                if (currentStep === 5) { // Just finished AI Review
                    currentStep = 6; // Set state to be ready for revision
                    toggleLoading(false);
                    elements.workflowButton.classList.add('hidden');
                    elements.revisionControls.classList.remove('hidden');
                } else {
                    currentStep++;
                    if (currentStep < workflowSteps.length) {
                        toggleLoading(false, 'ç¡®è®¤å¹¶ç»§ç»­');
                    } else {
                        log("ğŸ‰ å…¨éƒ¨æµç¨‹å·²å®Œæˆï¼");
                        toggleLoading(false, 'æµç¨‹ç»“æŸ');
                        elements.workflowButton.disabled = true;
                    }
                }
            } catch (error) {
                logError(`å·¥ä½œæµç¨‹åœ¨æ­¥éª¤ ${currentStep} ä¸­æ–­: ${error.message}`);
                toggleLoading(false, 'æµç¨‹å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }

        elements.workflowButton.addEventListener('click', () => {
             if (currentStep === 0) {
                graphState = { initial_prompt: elements.initialPrompt.value.trim() };
             }
             runWorkflow();
        });

        elements.reviseButton.addEventListener('click', async () => {
            const { apiKey, mainLlm, apiBaseUrl } = {
                apiKey: elements.apiKey.value.trim(),
                mainLlm: elements.mainLlm.value,
                apiBaseUrl: elements.apiBaseUrl.value.trim()
            };
            elements.reviseButton.disabled = true;
            elements.finishRevisionButton.disabled = true;
            log("âš™ï¸ æ­£åœ¨æ ¹æ®æ‚¨çš„ä¿®æ”¹è¿›è¡Œæ–°ä¸€è½®ä¼˜åŒ–...");

            try {
                await workflowSteps[6](apiKey, mainLlm, null, apiBaseUrl);
            } catch (error) {
                logError(`ä¿®è®¢ä¼˜åŒ–å¤±è´¥: ${error.message}`);
            } finally {
                elements.reviseButton.disabled = false;
                elements.finishRevisionButton.disabled = false;
            }
        });

        elements.finishRevisionButton.addEventListener('click', () => {
            elements.revisionControls.classList.add('hidden');
            elements.workflowButton.classList.remove('hidden');
            currentStep = 7;
            // Before moving on, save the final edited text to graphState
            const finalEditorContent = document.getElementById('editor')?.value;
            if (finalEditorContent) {
                 // Save the final editor content, which is the consolidated proposal body,
                 // into graphState.literature_review_draft.
                 graphState.literature_review_draft = finalEditorContent;
            }
            runWorkflow();
        });

        window.onload = () => {
            populatePrompts();
            updateKnowledgeBaseStatus(localStorage.getItem('knowledgeBase'));
            updateProviderUI(); // Set initial UI state for the default provider
            // fetchAndUpdateModels() is removed. Model fetching is now user-triggered.
        };

    </script>
</body>
</html>
